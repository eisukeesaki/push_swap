Sorting algo:
- if n_elm is 3, use sort-3-algo
	- call dedicated func by listing if conditions for all possible cases(5)
- else if n_elm is 5, use sort-5-algo
	- pb top 2 elms
	- use sort-3-algo to sort the remaining 3 elms in A
	- while B is not empty,
		- in A, find correct pos to push B
		- determine ra/rra 
		- rotate A until the found pos is at the top
		- pa
- else if n_elm is 7..200, use chunk algo
	- while A is not empty,
		- if B is not empty, rotate B until min is at the top. else skip this
		- in A, move min to top
		- pb
	- while B is not empty,
		- if in B, max is not at the top, rotate until it is. else skip this
		- pa

chunk algo (optimization):
- in A, count total elm
- calc base chunk size (total elm / chunk_n multiplier)
- while A is not empty,
	- increment chunk_n multiplier
	- if in A, there's an chunk_n member / A is not empty,
		- get pos of first elm to be found in chunk_n
		- if in A, chunk_n member is not @top / A is not empty,
			- determine ra/rra and call it x times to move chunk_n member to the top
		- if in A, chunk_n member is @top / A is not empty,
			- if B has only 1 elm or B is empty,
				- pb
		- if B has more than 1 elm, chunk_n member is @top, A is not empty,
			- determine rb/rrb and call it x times to move chunk_n member to the top
			- something?
- if A is empty
	- while B is not empty
		- determine rb/rrb and call it x times to move max to top
		- pa
- deallocate

------------------------------------------------------------------------------------------

<chunk algo>
SORTING ALGO
- if elm_n is 3 or 5, use 3 or 5 algo
- elseif elm_n is 7..200, use chunk algo
	- determine chunk size
	1. move elm of chunk_n to top of A
		- search for elm of chunk_n from top and bottom
		- choose one that requires less ins to move to top of A
			- compare idx of elm to middle idx of A
	2. if B is empty, pb
	2. else, move min in B to top
	3. pb
	- repeat 1-3 until all elm of chunk_n is pushed to B
	- repeat 1-3 to all remaining chunks
	4. move min in B to top
	5. pa
	- repeat 4-5 until all elm in B is pushed
- validate sort and emptiness of B
- free

- else if elm_n is 2,4,6, use insertion sort
- validation
- deallocate

case: stack_a has 10 unsorted valid numbers

- create linked list of stack_a
- check if stack_a is initially sorted
- count/store number of elms in stack_a
- calculate,determine chunk size
- find/store index of middle pos of stack_a
- find/store index of elm that's in the range of chunk_n (scan from both top/bottom and choose the one that requires less ins to move that to the top)
- choose ra or rra to move it to the top
- calculate and call ra or rra n times

</chunk algo>

if n_elms <= 100
g

- determine n_chunks
- scan stkA from top to find elm that belongs to ch_n and store it as ch_n_f
- scan stkA from bottom to find elm that belongs to ch_n and store it as ch_n_l
- compare ch_n_f and ch_n_l 
